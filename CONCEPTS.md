# อธิบายแนวคิดและเทคโนโลยีในโปรเจกต์ (สำหรับผู้เริ่มต้น)

ไฟล์นี้อธิบายว่าแต่ละเทคโนโลยีคืออะไร ใช้ทำไม และในโปรเจกต์จองตั๋วหนังเราใช้มันอย่างไร — อ่านแล้วจะเข้าใจภาพรวมโดยไม่ต้องมีพื้นฐานมาก่อน

---

## สรุปภาพรวมก่อนอ่านรายละเอียด

- **Redis** = เก็บข้อมูลในหน่วยความจำ เร็วมาก เราใช้ทำ 2 อย่าง: (1) **ล็อกที่นั่ง** ไม่ให้คนสองคนจองที่นั่งเดียวกันได้พร้อมกัน (2) **ส่งข่าว/เหตุการณ์** ระหว่างส่วนต่างๆ ของระบบ (เช่น จองสำเร็จ → ให้บันทึก log + แจ้งเตือน)
- **WebSocket** = การเชื่อมต่อแบบเปิดค้างไว้ ทำให้หน้าเว็บอัปเดตผังที่นั่งแบบทันที ไม่ต้องกด refresh
- **Message Queue (Redis Pub-Sub)** = ช่องทางส่ง “เหตุการณ์” (เช่น จองสำเร็จ, ปล่อยที่นั่ง) ไปให้ส่วนอื่นทำงานต่อ (บันทึก log, แจ้งเตือน) แบบไม่ให้ request ค้าง
- **MongoDB** = ฐานข้อมูลเก็บข้อมูลถาวร เช่น รอบฉาย, การจอง, บันทึก audit
- **Docker** = เครื่องมือให้รันแอป + ฐานข้อมูล + Redis ในคำสั่งเดียว โดยไม่ต้องลงของทีละตัวในเครื่องเรา

---

## 1. Redis เอาไว้ใช้อะไร

### Redis คืออะไร (แบบสั้นมาก)

Redis คือ **ฐานข้อมูลที่เก็บข้อมูลใน RAM (หน่วยความจำ)** ไม่ใช่ใน disk แบบ MongoDB  
เพราะอ่าน/เขียนจาก RAM เร็วมาก จึงเหมาะกับงานที่ต้องตอบสนองเร็วและไม่จำเป็นต้องเก็บถาวรยาวนาน

คิดง่าย ๆ เหมือน **กระดานประกาศกลาง** ที่ทุกคน (ทุก server) เข้าไปดูและเขียนได้เร็วมาก

### ในโปรเจกต์นี้เราใช้ Redis ทำ 2 อย่าง (ไม่ใช้เป็น “cache” เก็บข้อมูลเว็บ)

| ใช้ทำอะไร | อธิบายสั้น ๆ |
|-----------|----------------|
| **1. Distributed Lock (ล็อกที่นั่ง)** | เก็บว่า “ที่นั่งแถว X เก้าอี้ Y ถูกคนนี้ถือไว้แล้ว” เป็นเวลา 5 นาที — ทำให้คนอื่นจองที่นั่งเดียวกันไม่ได้จนกว่าจะปล่อยหรือหมดเวลา |
| **2. Pub/Sub (ส่งเหตุการณ์)** | เป็นช่องทางให้ backend “ประกาศ” ว่าเกิดเหตุการณ์อะไร (เช่น จองสำเร็จ, ปล่อยที่นั่ง) แล้วให้ส่วนอื่น (เช่น โปรแกรมบันทึก log) รับไปทำต่อ |

สองอย่างนี้เป็นคนละรูปแบบการใช้งาน Redis ในโปรเจกต์เดียวกัน

---

## 2. Distributed Lock (ล็อกแบบกระจาย) — ทำไมต้องมี

### ปัญหาที่ต้องแก้

ถ้ามี **หลายคนกดจองที่นั่งเดียวกันพร้อมกัน** โดยไม่มี “ล็อก”:

- Server อาจรับคำขอจาก User A และ User B พร้อมกัน
- ทั้งคู่อาจเห็นว่า “ที่นั่งว่าง” แล้วทั้งคู่ก็บันทึกว่า “จองแล้ว” ได้
- ผลลัพธ์: **Double Booking** — ที่นั่งเดียวขายสองครั้ง

### Lock คืออะไร (เปรียบเทียบ)

คิดเหมือน **การถือบัตรคิวหรือกุญแจห้อง**:

- คนแรกที่ “ยึด” ที่นั่งได้ ก็ถือ **lock** (กุญแจ) ไว้
- คนอื่นที่มาทีหลังจะ **ยึดไม่ได้** เพราะ key ถูกถือไปแล้ว
- เมื่อคนแรกจ่ายเงินเสร็จ หรือ **หมดเวลา** (เช่น 5 นาที) ระบบจะ **ปล่อย lock** ให้คนอื่นมาจองได้

### ทำไมต้อง “Distributed” (กระจาย)

คำว่า **Distributed** แปลว่า ระบบอาจมี **backend หลายตัว** (หลายเครื่อง หรือหลาย process):

- ถ้าใช้แค่ตัวแปรใน memory ของ process เดียว จะล็อกได้แค่ภายใน process นั้น — process อื่นไม่รู้
- เราเลยต้องใช้ **ที่เก็บกลาง** ที่ทุก process เข้าไปดูและยึด lock ได้ที่เดียวกัน — ในโปรเจกต์นี้ใช้ **Redis** เป็นที่เก็บกลางนี้

สรุป: **Redis Lock** = ใช้ Redis เป็น “ที่กลาง” ให้ทุก instance ของ backend มาขอ “กุญแจ” ที่นั่ง — ได้คนเดียวต่อหนึ่งที่นั่ง → **ไม่มี Double Booking**

---

## 3. Redis Lock ในโปรเจกต์เราทำยังไง (แบบเข้าใจง่าย)

- **Key (ชื่อกุญแจ):** `seat_lock:รหัสรอบฉาย:แถว:คอลัมน์`  
  เช่น `seat_lock:abc123:A:5` = ที่นั่งแถว A เก้าอี้ที่ 5 ของรอบฉาย abc123

- **Value (หมายเลขกุญแจ):** เป็น UUID ของคนที่ถือ lock ไว้  
  ใช้ตอนปล่อย lock — ระบบจะปล่อยได้เฉพาะคนที่ถือ UUID นี้ (กันปล่อยผิดคน)

- **TTL (อายุกุญแจ):** 5 นาที  
  หมายความว่า ถ้าไม่จ่ายเงินใน 5 นาที ระบบจะ “ปล่อย lock อัตโนมัติ” ให้ที่นั่งกลับเป็นว่าง

- **การยึด lock:** ใช้คำสั่งแบบ “สร้าง key ได้ก็ต่อเมื่อยังไม่มี” (NX)  
  → มีได้แค่คนแรกที่ยึดได้ คนอื่นยึดซ้ำไม่ได้

- **การปล่อย lock:** ใช้สคริปต์ที่ “ลบ key ได้ก็ต่อเมื่อ value ตรงกับ UUID ที่ถืออยู่”  
  → ไม่ไปปล่อย lock ของคนอื่นโดย mistake

อ่านรายละเอียดเทคนิคเพิ่มใน README ส่วน “Redis Lock Strategy”

---

## 4. WebSocket — ทำไมต้องมี และต่างจาก request ปกติยังไง

### Request ปกติ (HTTP)

- ผู้ใช้กดอะไรสักอย่าง → browser **ส่ง request** ไปที่ server → server **ตอบกลับครั้งเดียว** → จบ
- ถ้าอยากเห็นข้อมูลใหม่ (เช่น ผังที่นั่งเปลี่ยน) ต้อง **กด refresh** หรือให้หน้าเว็บ **ยิง request ซ้ำ** เป็นระยะ (polling) — ไม่เรียกว่า real-time แท้ ๆ

### WebSocket

- Browser กับ server **เปิดการเชื่อมต่อไว้ต่อกัน** (เหมือนสายโทรศัพท์ที่ต่อค้างไว้)
- พอมีเหตุการณ์เกิดขึ้น (เช่น มีคน lock ที่นั่ง หรือปล่อยที่นั่ง) server **ส่งข้อมูลออกไปทันที** ให้ทุก browser ที่ต่ออยู่
- หน้าเว็บจึง **อัปเดตผังที่นั่งได้ทันที** โดยไม่ต้องกด refresh = **Real-time**

### ในโปรเจกต์นี้

- เมื่อมีคนเลือกที่นั่ง → backend ล็อกที่นั่งแล้ว **ส่ง broadcast ผ่าน WebSocket** ไปทุก client
- ทุกคนที่เปิดหน้ารอบฉายเดียวกันจะ **เห็นที่นั่งเปลี่ยนเป็น LOCKED/BOOKED พร้อมกัน**  
นี่คือส่วน “Seat Map Real-time” ตามโจทย์

---

## 5. Message Queue (คิวข้อความ) และ Redis Pub/Sub

### Message Queue คืออะไร (แบบง่าย)

คิดเหมือน **กล่องรับจดหมาย**:

- มีคน **ส่งข้อความ** (event) เข้าไปใน “ช่อง” (channel) หนึ่ง
- มีคน/โปรแกรม **รับข้อความ** จากช่องนั้น แล้วไปทำอะไรต่อ (เช่น บันทึก log, ส่งอีเมล)

ข้อดีคือ **แยกส่วนงาน**: ส่วนที่จองเสร็จแค่ “ส่งข่าวว่าจองสำเร็จ” แล้วไปทำอย่างอื่นต่อได้ ส่วนที่รับข่าวจะไปบันทึก log หรือแจ้งเตือน — **ไม่ต้องให้ผู้ใช้รอ** จนบันทึก log เสร็จ

### Pub/Sub คืออะไร

- **Pub** = Publish (ประกาศ/ส่ง)
- **Sub** = Subscribe (สมัครรับ)

ใครก็ตามที่ **Subscribe** อยู่ที่ช่องหนึ่ง จะ **ได้ข้อความทุกอัน** ที่มีคน **Publish** เข้าช่องนั้น

### ในโปรเจกต์นี้ (Redis Pub-Sub)

- **Channel:** `booking_events`
- **เหตุการณ์ที่ Publish:** เช่น `BOOKING_SUCCESS`, `SEAT_RELEASED`
- **ผู้ Subscribe (ใน backend):** โปรแกรมที่รับ event แล้วไป
  1. **บันทึก Audit Log** ลง MongoDB (ว่าเกิดอะไร เมื่อไหร่)
  2. **Mock Notification** (ในโปรเจกต์แค่ log ข้อความ; ต่อจริงอาจเป็น Email / Line ได้)

ดังนั้น **Message Queue ในโปรเจกต์นี้ = Redis Pub/Sub** ใช้ส่ง “เหตุการณ์” จาก flow การจอง/ปล่อยที่นั่ง ไปให้ส่วน audit และ notification ทำงานต่อ — ไม่ใช่มี MQ ไว้เฉย ๆ ตามโจทย์

---

## 6. MongoDB เอาไว้ใช้อะไร

MongoDB คือ **ฐานข้อมูล** เก็บข้อมูลถาวร (ลง disk) เช่น

- ข้อมูลรอบฉาย ภาพยนตร์
- ข้อมูลการจอง (ใคร จองที่นั่งไหน รอบไหน สถานะอะไร)
- **Audit logs** — บันทึกว่าเกิดเหตุการณ์อะไร (จองสำเร็จ, timeout, ปล่อยที่นั่ง, lock fail)

ต่างจาก Redis ที่เราใช้เก็บ “สถานะล็อกชั่วคราว” และ “ส่งเหตุการณ์” ไม่ได้ใช้ MongoDB แทน Redis สำหรับ lock หรือ pub/sub

---

## 7. Docker และ docker compose

### Docker (แบบสั้น)

- เป็นเครื่องมือให้เรา “ห่อ” แอป + สิ่งที่แอปใช้ (เช่น โปรแกรมรัน, library) เป็น **container**
- รัน container แล้วได้สภาพแวดล้อมที่เหมือนกันทุกเครื่อง — “รันที่เครื่องฉันได้ ที่เครื่องเธอก็ได้”

### docker compose

- ใช้ไฟล์ `docker-compose.yml` กำหนดว่าจะรัน **หลาย container พร้อมกัน** และให้คุยกันได้ (network)
- ในโปรเจกต์นี้: **frontend (nginx + Vue), backend (Go), MongoDB, Redis** รันด้วยคำสั่งเดียว:

```bash
docker compose up --build
```

เราไม่ต้องลง MongoDB, Redis, Go หรือ Node ในเครื่องเราเอง — Docker จะดึง image และรันให้

---

## 8. Backend (Go + Gin) และ Frontend (Vue 3)

- **Backend:** โปรแกรมที่รันบน server รับ request จากเว็บ (และ WebSocket) ทำ logic จองที่นั่ง, ล็อก, ปล่อยล็อก, คุยกับ MongoDB และ Redis  
  เราใช้ภาษา **Go** และเฟรมเวิร์ก **Gin** ตามโจทย์

- **Frontend:** ส่วนที่ผู้ใช้เห็นใน browser — หน้าเว็บ Vue 3 แสดงผังที่นั่ง, ฟอร์มล็อกอิน, หน้า Admin  
  Frontend จะเรียก API (HTTP) และต่อ WebSocket กับ backend เพื่อดึงข้อมูลและอัปเดตแบบ real-time

---

## สรุปเทียบกับไดอะแกรมใน README

| สิ่งในระบบ | หน้าที่สั้น ๆ |
|------------|----------------|
| **Browser** | เปิดเว็บ Vue (frontend) |
| **nginx** | รับที่พอร์ต 80, แสดงหน้า Vue และส่ง request /api ไปที่ backend |
| **Backend (Gin)** | รับ API + WebSocket, ล็อก/ปล่อยที่นั่งผ่าน Redis, บันทึกการจองลง MongoDB, Publish event ไป Redis |
| **Redis** | เก็บ Lock (key ของที่นั่งที่ถูกยึด) + เป็น Pub/Sub ส่ง event จองสำเร็จ/ปล่อยที่นั่ง |
| **MongoDB** | เก็บข้อมูลถาวร: รอบฉาย, การจอง, audit_logs |
| **Worker (Lock Expiry)** | ตรวจเป็นระยะว่ามีการจองที่ค้างเกิน 5 นาทีไหม → ปล่อย lock, อัปเดตสถานะ, Publish SEAT_RELEASED, broadcast ผังใหม่ |
| **MQ Subscriber** | รับ event จาก Redis Pub/Sub → บันทึก audit ลง MongoDB + mock notification |

ถ้าอยากลึกเรื่องใดเป็นพิเศษ (เช่น Redis, WebSocket, หรือ flow การจองทีละขั้น) บอกได้ว่าจะขยายส่วนไหนในไฟล์นี้ให้ละเอียดขึ้นได้อีก
